<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Santos Gallegos (Posts about experience)</title><link>https://stsewd.dev/</link><description></description><atom:link href="https://stsewd.dev/categories/experience.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2024 &lt;a href="mailto:stsewd@proton.me"&gt;Santos Gallegos&lt;/a&gt; </copyright><lastBuildDate>Thu, 19 Dec 2024 18:30:14 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Advent of Code 2023 - solutions and my experience</title><link>https://stsewd.dev/posts/advent-of-code-2023/</link><dc:creator>Santos Gallegos</dc:creator><description>&lt;p&gt;&lt;a class="reference external" href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt; is a series of programming puzzles that are released every day in December up to Christmas.
Each day, two puzzles are released, the puzzles consist of a story and a set of input data,
and some examples of the expected output.&lt;/p&gt;
&lt;nav class="contents local" id="contents" role="doc-toc"&gt;
&lt;p class="topic-title"&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#top"&gt;Contents&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#the-start-of-a-journey" id="toc-entry-1"&gt;The start of a journey&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#embracing-differences-as-your-new-friends" id="toc-entry-2"&gt;Embracing differences as your new friends&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#my-daily-routine" id="toc-entry-3"&gt;My daily routine&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#the-right-tools-for-the-job" id="toc-entry-4"&gt;The right tools for the job&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#results-and-reflections" id="toc-entry-5"&gt;Results and reflections&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference internal" href="https://stsewd.dev/posts/advent-of-code-2023/#solutions" id="toc-entry-6"&gt;Solutions&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;
&lt;section id="the-start-of-a-journey"&gt;
&lt;h2&gt;The start of a journey&lt;/h2&gt;
&lt;p&gt;This is my first time participating in Advent of Code,
I've heard about it before but never really put in the time to participate.
Problem solving using programming isn't something new to me,
I've participated in several &lt;a class="reference external" href="https://stsewd.dev/posts/devsucodejam-2019"&gt;programming competitions&lt;/a&gt; in the past,
and &lt;a class="reference external" href="https://github.com/stsewd/programming-problems-rust"&gt;I like solving problems&lt;/a&gt; from &lt;a class="reference external" href="https://www.hackerearth.com/@stsewd"&gt;HackerEarth&lt;/a&gt; or similar platforms from time to time.
But over the years I've been doing less and less of this,
so this was a good opportunity to get back to it!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="embracing-differences-as-your-new-friends"&gt;
&lt;h2&gt;Embracing differences as your new friends&lt;/h2&gt;
&lt;p&gt;Advent of code is a bit different from other platforms/contests I've used before.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;You don't need to submit your code; you only submit the answer for a given input.
This means no time or memory constraints, the limit is your hardware and your time!
But finding an efficient and general solution is part of the fun.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There isn't an explicit time limit, you can take as long as you want to solve the problems.
But it's nice to be able to solve the two parts of the problem on the day they are released.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You don't need to solve the problems from the previous days to unlock the next day,
but you do need to solve the first part of a problem to unlock its second part.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;a class="reference external" href="https://adventofcode.com/2023/leaderboard"&gt;global ranking&lt;/a&gt; is only for the first 100 people that solved each problem.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These differences can be used to your advantage!&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Use any language you want with your favorite libraries, or any method you want.
Want to solve it by hand or &lt;a class="reference external" href="https://www.reddit.com/r/adventofcode/comments/189qs63/2023_day_3_a_successful_3rd_day_using_only_excel/"&gt;using Excel&lt;/a&gt;? Go ahead! Want to brute force the solution? Go ahead (if your program finishes before Christmas)!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Focus on solving the problem for just the given input, you don't need to worry about edge cases or generalizing your solution,
you can even search for patterns in the input.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="my-daily-routine"&gt;
&lt;h2&gt;My daily routine&lt;/h2&gt;
&lt;p&gt;My routine for each day was:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;Solve the first part in the morning (sometimes I read it at midnight and go dream about it).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solve the second part in the afternoon or evening.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Go to &lt;a class="reference external" href="https://www.reddit.com/r/adventofcode/"&gt;Reddit&lt;/a&gt; and see how other people solved the problem and check the memes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The best part of solving the problems with people around the world
is that you can see how others solved the problems, and how they struggled with the same problems you did.
It's always nice to read solutions that are more efficient or elegant than yours,
or some unusual solutions that you didn't think of, and learn from them.&lt;/p&gt;
&lt;p&gt;I refrained from opening Reddit until I solved both parts of the problem,
not even checked the memes (they may include spoilers or hints of the solution).
This was a good motivator to solve the problems as soon as possible.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-right-tools-for-the-job"&gt;
&lt;h2&gt;The right tools for the job&lt;/h2&gt;
&lt;p&gt;The tools I used:&lt;/p&gt;
&lt;dl class="simple"&gt;
&lt;dt&gt;Python&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;I used Python without external libraries,
since there is a lot of useful stuff in the standard library,
and it has several data structures built-in.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;Pen and paper&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;Essential for writing notes, manually testing solutions,
exploring formulas, looking for patterns, etc.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;Neovim&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;My editor of choice; I use Neovim, BTW.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;I focused on solving the problems in the most efficient way I could think of, while trying to maintain readability.
Maintaining readability isn't always easy to maintain, since solutions are bound to how complex the problem is, algorithms used, etc.
You are basically dumping the solution that was in your brain into the code,
and sometimes it's hard to make sense of it later or for other people that aren't
familiar with the steps you took to solve the problem or the algorithms you used.&lt;/p&gt;
&lt;p&gt;Focusing on solving the problem efficiently led me to overthink some solutions sometimes,
ending with solutions that were more complex than they needed to be,
or slower than a simpler solution.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="results-and-reflections"&gt;
&lt;h2&gt;Results and reflections&lt;/h2&gt;
&lt;p&gt;I solved 39 out of the 50 problems.
Up to the 19th day, I was really focused and solved most of the problems on the same day they were released.
The last five days I dedicated less time to solve the problems,
to enjoy the holidays and do other things away from the computer.
The problems got more complex too, I gave up on some,
the last three I didn't even read them.&lt;/p&gt;
&lt;figure&gt;
&lt;a class="reference external image-reference" href="https://stsewd.dev/images/advent-of-code-2023/personal-leaderboard.png"&gt;
&lt;img alt="My personal leaderboard" src="https://stsewd.dev/images/advent-of-code-2023/personal-leaderboard.png"&gt;
&lt;/a&gt;
&lt;figcaption&gt;
&lt;p&gt;My personal leaderboard&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;I'm happy with most of my solutions, and I learned a lot from reading others' solutions.
It was great seeing that I wasn't that rusty,
and that I was able to solve most problems without being completely stuck,
lots of thinking, but never completely stuck.&lt;/p&gt;
&lt;p&gt;Participating in Advent of Code was a great experience, but exhausting too,
50 problems in 25 days is a lot, specially during the holidays.&lt;/p&gt;
&lt;p&gt;On the positive side, it made me think about solving problems more often,
and read more about algorithms and data structures, especially graph theory.
I might revisit the unsolved problems in the future.&lt;/p&gt;
&lt;p&gt;That's all from my experience, now let's talk about the problems!
If you haven't solved them yet, I encourage you to try before reading my solutions.&lt;/p&gt;
&lt;aside class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Are you curious about how to prepare for these type of problems,
the algorithms you need to know, etc?
I may revive an old post I started writing about this topic some years ago if there is enough interest.
Comment below if you are interested!&lt;/p&gt;
&lt;/aside&gt;
&lt;/section&gt;
&lt;section id="solutions"&gt;
&lt;h2&gt;Solutions&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;"Talk is cheap. Show me the code."&lt;/p&gt;
&lt;p class="attribution"&gt;âLinus Torvalds&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The solutions are in Python, the only dependency is &lt;code class="docutils literal"&gt;pytest&lt;/code&gt; for testing the solutions.
To run the program for a specific input file, pass it as the first argument (&lt;code class="docutils literal"&gt;python &amp;lt;file.py&amp;gt; &amp;lt;input.txt&amp;gt;&lt;/code&gt;).
The solution starts in the &lt;code class="docutils literal"&gt;solve()&lt;/code&gt; function.
You can check all solutions in &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023"&gt;https://github.com/stsewd/advent-of-code-2023&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At continuation, I'll talk about each day and my solution for each part.
Note that this isn't a step-by-step guide to solving the problems,
but more of a general overview of my solution and my experience.
But I'll try to answer any questions you may have about my solutions in the comments.&lt;/p&gt;
&lt;p&gt;If you haven't solved the problems yet,
I encourage you to try before reading my solutions.&lt;/p&gt;
&lt;section id="day-01"&gt;
&lt;h3&gt;Day 01&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/1"&gt;https://adventofcode.com/2023/day/1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/01.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/01-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was a nice problem to start with, it was easy to solve, and it was a nice warm-up for the next problems.&lt;/p&gt;
&lt;p&gt;For the first part, I iterated from left to right till I found the first number,
and then from right to left till I found the second number.&lt;/p&gt;
&lt;p&gt;For the second part, I iterated from left to right till I found the first number, either a digit or a word, and then from right to left.
I used string operations like &lt;code class="docutils literal"&gt;str.find&lt;/code&gt; and &lt;code class="docutils literal"&gt;str.rfind&lt;/code&gt;.
I was curious how fast was this compared to using regular expressions,
so I wrote a second solution using regular expressions (&lt;code class="docutils literal"&gt;solve2&lt;/code&gt;),
it turned out to be slightly faster than my initial solution!&lt;/p&gt;
&lt;p&gt;Some people had problems with the second part with overlapping words like &lt;code class="docutils literal"&gt;eighthree&lt;/code&gt;,
solving this problem replacing the words to numbers wouldn't work.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-02"&gt;
&lt;h3&gt;Day 02&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/2"&gt;https://adventofcode.com/2023/day/2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/02.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/02-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another easy day.
For the first part, you needed to check that the number of cubes for a given color wasn't larger than the limit.&lt;/p&gt;
&lt;p&gt;For the second part, you needed to keep track of the largest number for each color.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-03"&gt;
&lt;h3&gt;Day 03&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/3"&gt;https://adventofcode.com/2023/day/3&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/03.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/03-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This day was also easy, a little long to write the solution, but still easy.&lt;/p&gt;
&lt;p&gt;For the first part, I tracked the start and end of each number,
and then used those positions to check if there was a symbol surrounding them.&lt;/p&gt;
&lt;p&gt;For the second part, I collected all the numbers' positions for each row,
and then iterated over each symbol and checked if it had exactly two numbers surrounding it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-04"&gt;
&lt;h3&gt;Day 04&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/4"&gt;https://adventofcode.com/2023/day/4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/04.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/04-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first part was easy, I used two sets and then intersected them to get the winner numbers.&lt;/p&gt;
&lt;p&gt;The second part, was a classic example of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Dynamic_programming"&gt;dynamic programming&lt;/a&gt;, recursion and memoization to the rescue!
The only &lt;em&gt;problem&lt;/em&gt; I had here was forgetting to count the initial cards.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-05"&gt;
&lt;h3&gt;Day 05&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/5"&gt;https://adventofcode.com/2023/day/5&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/05.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/05-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the first part, I created a list with the ranges,
and for each seed I'd check if its value was in any of those ranges,
and convert it to the new number.
The answer is the minimum value of the final value of the seeds.&lt;/p&gt;
&lt;p&gt;For part two, I created a list with the ranges sorted for each mapping so it would be easier to match them later,
then I applied a similar logic as the first part, but instead of keeping track of a single value, I kept track of ranges.
This is, we first start with a range, then we transform that range into another range, and so on.
The answer is the minimum value of all the final ranges.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-06"&gt;
&lt;h3&gt;Day 06&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/6"&gt;https://adventofcode.com/2023/day/6&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/06.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/06-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this problem, we need to find the times that beat the current record.
The &lt;em&gt;peak time&lt;/em&gt; (time pressing the button that allows us to travel as far a possible)
is the half of the allowed time, after the peak time the distance traveled decreases.&lt;/p&gt;
&lt;p&gt;With that in mind, we can count the distance traveled for each time from one to the peak time that beats the current record.
I first solved both parts by iterating over all those times till I found the best time,
but then I found that finding the best time can be done using a quadratic equation,
thus solving the problem in constant time,
but looping over was fast enough for the given input too.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-07"&gt;
&lt;h3&gt;Day 07&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/7"&gt;https://adventofcode.com/2023/day/7&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/07.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/07-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This problem requires a custom comparison between the two set of hands,
Python has a &lt;code class="docutils literal"&gt;functools.cmp_to_key&lt;/code&gt; function that can be used to compare two objects,
and can be used as the &lt;code class="docutils literal"&gt;key&lt;/code&gt; function for the sort/sorted functions.
Avoiding the need to create custom objects with a &lt;code class="docutils literal"&gt;__lt__&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;For the first part the comparison function was easy, just get the type for each hand and compare them,
to get the type of hand, we can use a &lt;code class="docutils literal"&gt;Counter&lt;/code&gt; to count the number of times each card appears in the hand.&lt;/p&gt;
&lt;p&gt;For the second part, I first got the type of the hand without the jokers,
and then &lt;em&gt;promoted&lt;/em&gt; the hand to the best possible hand with the jokers available.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-08"&gt;
&lt;h3&gt;Day 08&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/8"&gt;https://adventofcode.com/2023/day/8&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/08.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/08-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the first part I built a map of each node to its neighbors,
and then started from the node &lt;code class="docutils literal"&gt;AAA&lt;/code&gt; following the directions until I found the node &lt;code class="docutils literal"&gt;ZZZ&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the second part, I built a list with all the start nodes,
then I was thinking of the best way to follow the directions concurrently for each node and check if all of them reached their end node,
I tested each node separately and found that after reaching their end node, each node will go back to their start node.
With that information, it was just a matter of remembering the mathematical function to calculate when all nodes will be at their end node at the same time,
that function is the least common multiple (&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Least_common_multiple"&gt;LCM&lt;/a&gt;) of the number of steps of each node's cycle.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-09"&gt;
&lt;h3&gt;Day 09&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/9"&gt;https://adventofcode.com/2023/day/9&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/09.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/09-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this problem, I overthought the solution finding a formula, thinking it would pay off in the second part.
After writing some examples on paper, I found that the solutions followed the pattern of a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Pascal's_triangle"&gt;Pascal's triangle&lt;/a&gt;
(at the time I didn't remember the name of the triangle, so I had to Google for "math triangle 1").&lt;/p&gt;
&lt;p&gt;For the second part, the problem just asked for the value of the start,
so it was a matter of doing the same operation, but with the list reversed.&lt;/p&gt;
&lt;p&gt;Probably wasted a lot of time, but I'm happy that I was able to solve the problem in linear time,
and that I was able to remember the name of the Pascal's triangle.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-10"&gt;
&lt;h3&gt;Day 10&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/10"&gt;https://adventofcode.com/2023/day/10&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/10.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/10-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was problem was hard for me, I was stuck in the second part for 4 days.
But more than stuck, I think I was blocked, like I knew the solution was there, but was having a hard time implementing it.&lt;/p&gt;
&lt;p&gt;For the first part I started by trying to follow each valid path recursively,
but then I realized that there was just one valid path, so I just followed the first valid path I found.&lt;/p&gt;
&lt;p&gt;For the second part, I tried to think of different ways to fill the polygon,
but none of them seemed to work for all the cases.
The solution that worked for most cases was to try to fill the polygon from left to right pairing the vertical edges,
but I was having a hard time figuring out the rules to pair the edges.
After failing for several days, I decided to search for existing algorithms for filling a polygon.
I found the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Scanline_rendering"&gt;Scanline algorithm&lt;/a&gt;, and after &lt;a class="reference external" href="https://www.geeksforgeeks.org/scan-line-polygon-filling-using-opengl-c/"&gt;reading&lt;/a&gt; &lt;a class="reference external" href="https://www.cs.drexel.edu/~deb39/Classes/CS430/Lectures/L-05_Polygons.pdf"&gt;about it&lt;/a&gt; and understanding it, I was able to implement it in Python,
I'm happy that the solution I was trying to implement was similar to how this algorithm works,
but also I should have searched for this algorithm earlier. You live, you learn.&lt;/p&gt;
&lt;p&gt;After reading others' solutions, I found that there was an even simpler solution
using the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Pick's_theorem"&gt;Pick's theorem&lt;/a&gt; to get the number of points inside a polygon
(this came handy for Day 18!).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-11"&gt;
&lt;h3&gt;Day 11&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/11"&gt;https://adventofcode.com/2023/day/11&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/11.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/11-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I initially solved the first part expanding the grid,
but after reading the second part I realized that I could just keep track of the rows/columns that needed to be expanded,
and use that to calculate the final answer.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-12"&gt;
&lt;h3&gt;Day 12&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/12"&gt;https://adventofcode.com/2023/day/12&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/12.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/12-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I solved this problem by recursively testing what would be the result if each of the &lt;code class="docutils literal"&gt;?&lt;/code&gt; would be replaced by a &lt;code class="docutils literal"&gt;#&lt;/code&gt; or &lt;code class="docutils literal"&gt;.&lt;/code&gt;,
and instead of copying the rest of the string and group, I just passed their indexes to the function.
This solution was fast for the first part, for the second I had to implement a cache to avoid recalculating the same group twice,
the cache was per each row, it took around 4 seconds to complete, I saw other people applying the cache to the whole matrix,
I may try that later and see if it's faster.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-13"&gt;
&lt;h3&gt;Day 13&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/13"&gt;https://adventofcode.com/2023/day/13&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/13.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/13-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead of doing the operations over the matrix,
I used a binary number to represent the state of each row and column,
then finding the line of reflection was just a matter of comparing numbers.&lt;/p&gt;
&lt;p&gt;For the second part, I brute forced the solution,
since I was using binary numbers, getting the possible combinations was
a matter of flipping the bits using a &lt;code class="docutils literal"&gt;XOR&lt;/code&gt; operation.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-14"&gt;
&lt;h3&gt;Day 14&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/14"&gt;https://adventofcode.com/2023/day/14&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/14.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/14-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first part was easy, moving all rocks till we reach a &lt;em&gt;blocker&lt;/em&gt; (another rock or the end of the grid).&lt;/p&gt;
&lt;p&gt;For the second part, I &lt;em&gt;cheated&lt;/em&gt; a little by using the rules to my advantage,
this is, solving the problem for the given input only.
Analyzing the first 200 iterations, I found that after some iterations a pattern repeats,
so I manually searched for the start of the pattern, and the number of iterations it takes to repeat.
Then, I did some math to get the minimum number of iterations to reach the final answer.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-15"&gt;
&lt;h3&gt;Day 15&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/15"&gt;https://adventofcode.com/2023/day/15&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/15.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/15-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This day was easy for both parts, a nice rest for a Friday.&lt;/p&gt;
&lt;p&gt;The first part you just needed some basic math operations, sum and modulo.&lt;/p&gt;
&lt;p&gt;For the second part, you needed some linked list operations,
but instead of using a linked list, I used a dictionary for quick access to the elements,
this is since Python 3.7+ preserves the insertion order of the elements in a dictionary.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-16"&gt;
&lt;h3&gt;Day 16&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/16"&gt;https://adventofcode.com/2023/day/16&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/16.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/16-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this problem, I traversed the matrix following the directions from the mirrors, while keeping track of the points and their direction that were visited.
The result is the number of unique points visited without taking into consideration the direction.&lt;/p&gt;
&lt;p&gt;For the second part, I was thinking of using dynamic programming to solve it efficiently,
but wasn't sure how to do it while keeping track of previous visited points.
So, I just iterated over all start positions and directions and kept track of the maximum number of points visited on each iteration,
it completed under two seconds, so I didn't bother optimizing it further.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-17"&gt;
&lt;h3&gt;Day 17&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/17"&gt;https://adventofcode.com/2023/day/17&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This one was another hard one for me. I wasn't able to solve it.&lt;/p&gt;
&lt;p&gt;After failing to solve it using recursion,
I realized that this was a path finding problem,
probably a variation of Dijkstra's algorithm.
My knowledge about graph theory and friends is a little rusty,
so I started reading and understanding Dijkstra's algorithm,
but I wasn't able to adapt it to this problem.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-18"&gt;
&lt;h3&gt;Day 18&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/18"&gt;https://adventofcode.com/2023/day/18&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/18.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/18-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An easy day, great start for a Monday, a relief after day 17.
Well, it's easy if you already solved Day 10, since it's the same principle.&lt;/p&gt;
&lt;p&gt;On day 10 I learned about &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Pick's_theorem"&gt;Pick's theorem&lt;/a&gt; to get the number of points inside a polygon,
and I also about the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Shoelace_formula"&gt;shoelace formula&lt;/a&gt; to get the area of a polygon.
Using both formulas, I was able to solve the problem in linear time.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-19"&gt;
&lt;h3&gt;Day 19&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/19"&gt;https://adventofcode.com/2023/day/19&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/19.py"&gt;Part 1&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/19-2.py"&gt;Part 2&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This problem was similar to Day 05.
For the first part, I built a map with the workflows,
and followed them until reaching the workflow &lt;code class="docutils literal"&gt;A&lt;/code&gt; or &lt;code class="docutils literal"&gt;R&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the second part, we had to find a range of values that would satisfy the given conditions,
but here the ranges had branches, so I recursively collected all the possible ranges that reached to the &lt;code class="docutils literal"&gt;A&lt;/code&gt; workflow,
the final solution was a matter of multiplying those ranges.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-20"&gt;
&lt;h3&gt;Day 20&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/20"&gt;https://adventofcode.com/2023/day/20&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/20.py"&gt;Part 1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Part one was kind of easy,
the hardest part was understanding the operations for each type of module,
after that I looped over the operations till we didn't have any more operations to process.&lt;/p&gt;
&lt;p&gt;I wasn't able to solve part two,
I tried for like two hours, and then gave up.
Didn't even bother on trying to solve it later.&lt;/p&gt;
&lt;p&gt;Probably was on this day when I decided to dedicate less time to solve the problems, and enjoy more the holidays.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-21"&gt;
&lt;h3&gt;Day 21&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/21"&gt;https://adventofcode.com/2023/day/21&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/21.py"&gt;Part 1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For part one I recursively traversed the matrix,
and realized that if the remaining steps were even,
returning to the previous position was guaranteed,
avoiding having to check what would happen if we went back.
That with a simple cache was fast enough to solve the first part.&lt;/p&gt;
&lt;p&gt;The second part was more difficult, and wasn't able to solve it,
I tried for like one hour, and then gave up.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-22"&gt;
&lt;h3&gt;Day 22&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Problem: &lt;a class="reference external" href="https://adventofcode.com/2023/day/22"&gt;https://adventofcode.com/2023/day/22&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution: &lt;a class="reference external" href="https://github.com/stsewd/advent-of-code-2023/blob/main/22.py"&gt;Part 1&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I solved this one on the next day, I was busy with the holidays and social life.&lt;/p&gt;
&lt;p&gt;I haven't played with 3D matrices in a while,
so it took me a while to think of a solution that was easy to code.&lt;/p&gt;
&lt;p&gt;Drawing inspiration from Dijkstra's algorithm,
I sorted all bricks by their z coordinate,
and for each brick I checked all bricks below it, searching for one that would &lt;em&gt;stop&lt;/em&gt; it by checking if their x and y coordinates intersected.
After that, I built a map with all the bricks and the bricks above it that intersected with it.
To get the final answer, I used a set difference, if the set was empty, the brick could be safely removed.
It was a long solution, but it was still fast.&lt;/p&gt;
&lt;p&gt;For the second part, I used the same logic from the first part,
but instead of using sets, I built a graph with the bricks and their intersections,
and recursively exploring the bricks that will fall,
it worked for the example, and it made sense on paper,
but the solution was wrong for the given input,
so I gave up after that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="day-23-25"&gt;
&lt;h3&gt;Day 23-25&lt;/h3&gt;
&lt;p&gt;As previously mentioned, I didn't even read the problems for these days.
I went to enjoy the holidays, and do other things away from the computer.
I may go back and try to solve these problems some day.&lt;/p&gt;
&lt;p&gt;Hope you enjoyed reading about my experience and solutions!
See you next year!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;</description><category>experience</category><category>problem solving</category><guid>https://stsewd.dev/posts/advent-of-code-2023/</guid><pubDate>Wed, 27 Dec 2023 05:00:00 GMT</pubDate></item><item><title>A tale about security in web applications, or how I helped to save a bank from bankruptcy</title><link>https://stsewd.dev/posts/a-tale-about-security-in-web-applications/</link><dc:creator>Santos Gallegos</dc:creator><description>&lt;p&gt;Hi friend, today I'm going to tell you a little story.
Some things may look familiar, or even you could feel related to some situations.
I assure you, &lt;strong&gt;it's mere coincidence&lt;/strong&gt;.&lt;/p&gt;
&lt;section id="a-new-experience"&gt;
&lt;h2&gt;A new experience&lt;/h2&gt;
&lt;p&gt;This tale takes place in Ecuador.
It was during the lockdown that some friends contacted me to help them with a security audit.
They were forming a team (with special abilities?),
and there was missing someone with programming/web skills.&lt;/p&gt;
&lt;p&gt;I was a little nervous to say yes,
since I haven't had much experience with security in the field.
But it was comforting to know that my teammates had vast experience in it.
I was excited to learn new things from them, and how the world of security, auditing, and banking works.
Oh, and I would get one of those fancy permits (salvoconducto) to go outside during lockdown.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Wait, "banking"?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Oh, sorry I didn't tell you, the security audit was for a small bank.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="first-flight"&gt;
&lt;h2&gt;First flight&lt;/h2&gt;
&lt;p&gt;And &lt;em&gt;the day&lt;/em&gt; arrived.
We started with their homepage, and some small web applications.
It didn't take me much time to start finding small security bugs.
And then not so small, but not &lt;em&gt;that&lt;/em&gt; critical either,
mostly things returning too much data or returning data when they shouldn't.
And it was from some old applications, so there wasn't much surprise in there,
and the data exposed wasn't from all their clients.&lt;/p&gt;
&lt;p&gt;After reporting some of those bugs that seemed important to get fixed soon
we moved on to our next target: &lt;strong&gt;the online banking application&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We started with a black box test (no user).
It wasn't long since we started to find minor security bugs.
And we found some indications that the API may not be doing an appropriate check for authorization,
but without a user, it wasn't easy to guess (yet!).&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;What indications?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Well, most of their APIs required a user ID to be present in the request.
So, instead of relying on some session cookie or authorization token previously validated by the server,
&lt;strong&gt;they were asking the client to explicitly pass the user's ID&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Oh, I see, that smells bad.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="access-granted"&gt;
&lt;h2&gt;Access granted&lt;/h2&gt;
&lt;p&gt;After we got tired of guessing what some APIs would do and their parameters,
we created a new user and started our gray box testing.
The first thing we did was to check those precious API requests,
the parameters being sent, cookies, etc.
And then, the test we all were waiting for.
Changing the user from the request to another one...
Bingo! We got access. I mean, &lt;strong&gt;damn, we got access???&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After that shocking reveal, we kept digging for more endpoints to test.
The obvious one was to try to transfer money from/to other accounts, but there was a little problem.
An &lt;a class="reference external" href="https://en.wikipedia.org/wiki/One-time_password"&gt;OTP&lt;/a&gt; was required for each transaction.
So we first made a real transaction to check how the API works...
We realized that the OTP wasn't needed at all! &lt;strong&gt;It was being validated from the client side!&lt;/strong&gt;
So, yes, we were able to transfer money to any account &lt;strong&gt;and&lt;/strong&gt; from any account.
The user IDs were all incremental,
which means that you could easily steal money from everyone in the bank.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Damn! THAT IS SHOCKING! Someone could have easily emptied the accounts of everyone!
But it would have been very obvious if it has happened.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Or just steal 50 cents from everyone in the bank each month.
Do you really know exactly how much money do you have in your bank account?
Would you even care if only 50 cents were missing?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That's a low and long game to play, but still easy to track.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Or you could just buy things, and pay with a wire transfer.
That way the money goes to several people instead of just one.
There are more ways you could exploit this without anyone noticing it, for sure.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="interlude-about-boxes"&gt;
&lt;h2&gt;Interlude - about boxes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;So, you did a black and gray box tests, is there a white one? and what those colors mean?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The color thing is about how much information and access you have to the application.
In a black box test, you don't know anything about the system internals.
In a gray box test, you have some knowledge of the application, like the architecture,
technologies being used and intern access to the application (like a user!).
And finally the white one, you have access to the source code.
But we didn't do that one.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="consequences"&gt;
&lt;h2&gt;Consequences&lt;/h2&gt;
&lt;p&gt;At this point more than shocked, &lt;strong&gt;I was scare and disappointed&lt;/strong&gt;.
Scare of knowing this vulnerability existed and was &lt;strong&gt;easy to exploit&lt;/strong&gt;.
The money from all the people was in danger, maybe even their lives!
And disappointed to know that this application has been sold to this bank (and others!) for a lot of money,
and the company behind it has been doing so for more than 15 years.
And also, that all these banks have been for many security audits,
and &lt;strong&gt;NO ONE&lt;/strong&gt; found any of the things we reported.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;What do you mean with their lives were in danger?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You could disagree with me on this one,
personally I think that a bank is a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Safety-critical_system"&gt;SCS&lt;/a&gt;,
Nothing good can happen
if something goes wrong with people's money,
or all their savings.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No one found that after several audits? WOW! Why do you think they missed them?
And how the developers missed that!?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sadly. Laziness, inexperience and negligence.
Here people don't like to go very &lt;em&gt;technical&lt;/em&gt;,
but instead go with degrees and certifications ($$$).
And when doing the audit, they only run automated tools
without doing any manual checking, or trust that the apps are secure,
or everyone in the team knows only about networking.
And from the developers side, what can I say?
Most developers here don't know what a unit test is,
or are afraid to say "I'm not qualified to build this, we need someone else".&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="not-surprised"&gt;
&lt;h2&gt;Not surprised&lt;/h2&gt;
&lt;p&gt;I can't say this was &lt;em&gt;that&lt;/em&gt; shocking,
I mean, I have seen things like this on several apps in my country before,
but seeing this happening in a bank... that's another thing.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;So, what happened after you reported this?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Well, the company behind the application negated that the bug existed,
but we provided enough proofs in our report that invalidated all those claims.
And they even charged the bank for fixing those vulnerabilities.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WTF? That's unethical.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Yeah, but sadly I learned that's how the banking/enterprise world works.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;We found more shocking things&lt;/strong&gt;, but I may tell you that in another occasion.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-end"&gt;
&lt;h2&gt;The end&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;If you are a developer&lt;/strong&gt;, please always make sure to write tests for you code,
especially if you are dealing with sensitive data.
If you feel you may not have enough experience to work on something,
don't be afraid to say so, and ask for help.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If you are doing a security audit&lt;/strong&gt;,
please bring a diverse team,
or be clear with the client about what things you may not be dealing with.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If you are looking to do a security audit at your company&lt;/strong&gt;,
I may know a great team with experts in different areas that &lt;a class="reference external" href="https://stsewd.dev/about"&gt;you could hire&lt;/a&gt;.&lt;/p&gt;
&lt;aside class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;This tale may have been inspired by a real situation,
and some things may have been exaggerated (or maybe not?).&lt;/p&gt;
&lt;/aside&gt;
&lt;/section&gt;</description><category>experience</category><category>security</category><guid>https://stsewd.dev/posts/a-tale-about-security-in-web-applications/</guid><pubDate>Fri, 18 Jun 2021 05:00:00 GMT</pubDate></item><item><title>Devsu Code Jam 2019 - solutions and my experience</title><link>https://stsewd.dev/posts/devsucodejam-2019/</link><dc:creator>Santos Gallegos</dc:creator><description>&lt;p&gt;Last year I participated in the &lt;a class="reference external" href="https://www.devsucodejam.com/"&gt;Devsu Codejam 2019&lt;/a&gt; contest,
which is about solving programming problems.
The first place? A car ð.&lt;/p&gt;
&lt;p&gt;The contest was for all developers from Ecuador,
this is the first time I have heard about this type of contests being organized in Ecuador,
so it caught my attention (well, the car a little too).&lt;/p&gt;
&lt;figure class="align-center"&gt;
&lt;img alt="/images/devsucodejam-2019/web.png" src="https://stsewd.dev/images/devsucodejam-2019/web.png"&gt;
&lt;figcaption&gt;
&lt;p&gt;Devsu Codejam front page&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;First, a little of background about myself.
I have participated in some contests about problem solving in the past:
three times in the &lt;a class="reference external" href="https://ieeextreme.org/"&gt;IEEEXtreme programming&lt;/a&gt; (before the university kicked me out),
and a couple on &lt;a class="reference external" href="https://www.hackerrank.com/stsewd"&gt;Hackerrank&lt;/a&gt;, so I'm kind of familiar with them.
I stopped participating in these kind of contests for a while,
so this was a good opportunity to get back into the game.&lt;/p&gt;
&lt;p&gt;The contest was split into two categories (students and professionals), and it had two rounds.
The first round was online (November 23th), and was around ~4 hours with 16 problems.
The first 50 of each category from the first round could go the second round held in Quito,
the capital of Ecuador (November 30th), this phase was around 3 hours with 10 problems.&lt;/p&gt;
&lt;p&gt;I participated in the professionals category.
And got the 10th place in the first round, and the 7th place in the final round.
What? Did you think I won the car? Sorry friend, I didn't mean to disappoint you.&lt;/p&gt;
&lt;p&gt;Anyway, I arrived at Quito the day before the contest,
met some friends and got drunk, and didn't get much sleep.
And the day of the contest my allergies didn't play nice...
so I had a running nose during the whole contest.
And yes, those are silly excuses, but a 7th place isn't bad ð
(and they gave some prizes to the first 10 of each category).&lt;/p&gt;
&lt;p&gt;That was my experience, now let's get back to the problems.
I uploaded my solutions from the first round here
&lt;a class="reference external" href="https://github.com/stsewd/devsucodejam-2019"&gt;https://github.com/stsewd/devsucodejam-2019&lt;/a&gt; and from the final round here &lt;a class="reference external" href="https://github.com/stsewd/devsucodejam-2019-final"&gt;https://github.com/stsewd/devsucodejam-2019-final&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I don't have access to the platform with all the test cases,
so I can't guarantee all the solutions are correct,
but I believe most of them are :).&lt;/p&gt;
&lt;aside class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;First I was planning in writting the explanation for all solutions,
but then I realized the posts would be too long to read &lt;em&gt;and write&lt;/em&gt;...
So I'm just linking to my solutions instead,
if you have any questions about one of them let me know,
maybe I'll do another post explaining those solutions.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Some final words, I encourage &lt;strong&gt;you&lt;/strong&gt; to keep solving problems in platforms like &lt;a class="reference external" href="https://www.hackerrank.com/"&gt;hackerrank&lt;/a&gt; and &lt;a class="reference external" href="https://hackerearth.com/"&gt;hackerearth&lt;/a&gt;.
You'll realize how using a different algorithm or data structure will make your programs faster,
how some small optimizations can make a big difference when handling large amounts of data,
start thinking outside the box when solving real-life problems,
and see math as your best friend when solving problems.&lt;/p&gt;
&lt;p&gt;And there is another plus,
when solving problems, at the same time you'll be building your portfolio,
and showing your &lt;em&gt;real skills&lt;/em&gt; to the world.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you want to master a programming language, solving problems is a fun way to do it!&lt;/em&gt;&lt;/p&gt;</description><category>experience</category><category>problem solving</category><guid>https://stsewd.dev/posts/devsucodejam-2019/</guid><pubDate>Fri, 02 Oct 2020 05:00:00 GMT</pubDate></item></channel></rss>